### 一、CSS

1. 修改滚动条样式

   ```css
   /*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/
   ::-webkit-scrollbar {
     width: 8px;
     height: 8px;
     background-color: #f0f2f5; }
   /*定义滚动条轨道 内阴影+圆角*/
   ::-webkit-scrollbar-track {
     border-radius: 8px;
     background-color: #f0f2f5; }
   
   /*定义滑块 内阴影+圆角*/
   ::-webkit-scrollbar-thumb {
     border-radius: 8px;
     background-color: #b5babf; }
   ```

2. 



### 二、Js

1. IOS手机webview页面在锁屏和Home回到桌面后，**Js不执行**，Android可以。

   比如，计时器，需要记录和本地时间比较，修正

2. Js**计算精度**问题

   比如，0.1+0.2就会出现过长位数，这是由于Js采用的是64位双精度计算方法，导致其不适合金融相关的精密计算。可以采用先转换成整数在进行加减修正。

3. **四舍五入**

   常用的四舍五入方法有：.toFixed()、Math.round()，前者是5舍6入，一般使用后者，通常先都转换成整数再处理，处理成整数不能使用*100这种方式，因为1.255 * 100也是有问题的，需要转换成字符串，移除小数点转换成整数。

4. 移动端时间转换

   Android和IOS能识别的日期区间格式有区别，都能识别的写法是

   ```js
   new Date("2018/04/27 11:11:11")
   ```

5. 移动端浮层出现、消失，页面禁止滑动、允许滑动

   ```js
   // 禁止默认事件，这里要提出来，不然没有效果
   function preventDefault(e) {
       e.preventDefault();
   }
   //浮层出现禁止body滑动
   function disableScroll() {
       document.body.addEventListener('touchmove',preventDefault,{passive:false});
   }
   //浮层消失允许body滑动
   function enableScroll() {
       document.body.removeEventListener('touchmove',preventDefault,{passive:false});
   }
   ```

6. Js addEventListener('click',function(){},true)

   - 第二个参数需要提出来封装好，因为addEventListener和removeEventListener第二个参数需要一致，第三个参数只会检查capture参数，所以不能使用匿名函数；
- 第三个函数true代表捕获阶段执行，false表示冒泡阶段执行；用于控制事件触发顺序；
   - addEventListener和removeEventListener需要成对出现，因为dom移除之后addEventListener还存在，会影响设备内存；
- 移动端scroll事件可以把capture设为true，增加性能；
   
7. **SVG**

   - 创建svg dom结构，使用Jquery.html()，某些浏览器版本不兼容，需要使用：

     ```JS
     // 创建svgdom函数
     function createSVGDom(name) {
         return document.createElementNS('http://www.w3.org/2000/svg',name);
     }
     ```

   - 获取svg结构上的属性

     ```js
     // 添加属性,包括id，class都可以
     createSVGDom(name).getAttribute('name')
     createSVGDom(name).setAttribute('name')
     ```

   - 获取svg中text元素的文本

     ```JS
     // 创建text之后添加值
     createSVGDom('text').innerHTML=''
     createSVGDom('text').textContent=''
     ```

   - 获取元素高宽和坐标

     ```JS
     createSVGDom(name).getBBox()
     ```

   - 事件处理

     ```JS
     createSVGDom(name).addEventListener('click',function(){})
     ```

8. **Canvas**

   

9. Js动画方案requestAnimationFrame

   ```JS
   let RAF = (function () {
       return window.requestAnimationFrame ||
           window.webkitRequestAnimationFrame ||
           window.mozRequestAnimationFrame ||
           window.oRequestAnimationFrame ||
           window.msRequestAnimationFrame ||
           function (callback) {
           	window.setTimeout(callback, 1000 / 60);
       	};
           })()
   ```

10. 关于函数中arguments.callee

    arguments.callee指向的是该函数。

    一般递归调用为了防止内部与函数名过于耦合，所以会有需要使用arguments.callee的场景，但是arguments是一个非常庞大的对象，而且递归调用的过程中this会发生改变，不推荐使用，所以会临时定义一个变量作为函数名

    ```js
    function show(n) {
        var arr = [];
        return (function fn() {
            arr.unshift(n);
            n--;
            if (n !== 0) {
                fn();
            }
            return arr;
    
        })()
    }
    show(5)//[1,2,3,4,5]
    ```

11. 如何修改**函数this**的指向？

    函数中的this指向的是window，如果函数是够构建函数，那么，经过new构建之后，this指向的是这个结构体。

    bind()、call()、apply()这三个都是改变函数this指向的办法。三个传参方法如下：

    ```js
    let obj={
        name:'熊万',
        age:'17'
        myFun:function(f,t){
            console.log(`${this.name} 年龄 ${this.age}，来自${f}去往${t}`)
        }
    }
    let db={
        name:'德玛',
        age:'99'
    }
    obj.myFun.call(db,'成都','上海')；　　　　 // 德玛 年龄 99  来自 成都去往上海
    obj.myFun.apply(db,['成都','上海']);      // 德玛 年龄 99  来自 成都去往上海  
    obj.myFun.bind(db,'成都','上海')();       // 德玛 年龄 99  来自 成都去往上海
    obj.myFun.bind(db,['成都','上海'])();　　 // 德玛 年龄 99  来自 成都, 上海去往 undefined
    ```

    **bind()返回的是一个新方法，需要调用才执行。**

    第一个参数都是this的指向对象;

    后续传参call()和bind()一致，都是分别传进去的，apply()后续参数是以一个数组的形式传进去的。

12. 数组操作方法



### 三、Vue



### 四、React



### 五、TypeScript



### 六、ES7、ES7...

1. Promise.then()中错误处理和.catch()的区别

   .then()中如果第一个函数错了，第二个函数是捕捉不到的，但是catch()可以，这里两种用法都有用途。

   比如，在Promise.all()中，如果第一个promise报错，后续的就不执行了，这里就可以采用第一种的错误处理方法。可以不阻塞后面的执行。



### 七、Git

1. 多人修改同一文件操作步骤

   a. 本地stash -> git pull -> stash pop -> 解决冲突 -> git add -> git commit -> git push

   b. git commit -> git pull -> git push 这样子操作会产生一个merge branch的分支

   c. git commit -> git fetch -> rebase -> git push 可以避免b中出现merge分支